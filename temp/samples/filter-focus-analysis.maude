load ../tool2 .
load filter .

mod MODEL is
  pr FILTER .
  inc SATISFACTION .
  inc OBSERVATION .

  subsort Conf < State .

  var S : State .
  var VS : VictSet .  var PS : ProcSet .
  vars I J L : Nat .

  --- Defining State Propositions ---
  op twoCrits : -> Prop [ctor] .
  eq [tempEQ1] : VS ; proc(I, L, crit) proc(J, L, crit) PS:ProcSet |= twoCrits = true .
  eq [tempEQ2] : S |= twoCrits = false [owise] .

  op waitLHS : -> Prop [ctor] .
  eq [tempEQ3] : vict(s L, J) VS ; proc(I, L, on) PS |= waitLHS = true .
  eq [tempEQ4] : S |= waitLHS = false [owise] .

  op filterLHS : -> Prop [ctor] .
  ceq [tempEQ5] : VS ; proc(I, L, wait) PS |= filterLHS = true
    if L < @NL and not conflict(I, L, VS ; proc(I, L, wait) PS) .
  eq [tempEQ6] : S |= filterLHS = false [owise] .

  op critLHS : -> Prop [ctor] .
  ceq [tempEQ7] : VS ; proc(I, L, on) PS |= critLHS = true
    if s L = @NL .
  eq [tempEQ8] : S |= critLHS = false [owise] .

  op exitLHS : -> Prop [ctor] .
  eq [tempEQ9] : VS ; proc(I, L, crit) PS |= exitLHS = true .
  eq [tempEQ10] : S |= exitLHS = false [owise] .


  --- Focus IDs ---
  ops f1 f2 : -> Nat .
  eq [tempEQ11] : f1 = 1 .  eq f2 = 2 .

  --- Focus/Star LHS Propositions ---
  ops waitLHSF1 waitLHSF2 waitLHSStar : -> Prop [ctor] .
  eq [tempEQ12] : vict(s L, J) VS ; proc(f1, L, on) PS |= waitLHSF1 = true .
  eq [tempEQ13] : S |= waitLHSF1 = false [owise] .
  
  eq [tempEQ14] : vict(s L, J) VS ; proc(f2, L, on) PS |= waitLHSF2 = true .
  eq [tempEQ15] : S |= waitLHSF2 = false [owise] .
  
  ceq [tempEQ16] : vict(s L, J) VS ; proc(I,  L, on) PS |= waitLHSStar = true
    if I =/= f1 and I =/= f2 .
  eq [tempEQ17] : S |= waitLHSStar = false [owise] .
  

  ops filterLHSF1 filterLHSF2 filterLHSStar : -> Prop [ctor] .
  ceq [tempEQ18] : VS ; proc(f1, L, wait) PS |= filterLHSF1 = true
    if L < @NL and not conflict(f1, L, VS ; proc(f1, L, wait) PS) .
  eq [tempEQ19] : S |= filterLHSF1 = false [owise] .
  
  ceq [tempEQ20] : VS ; proc(f2, L, wait) PS |= filterLHSF2 = true
    if L < @NL and not conflict(f2, L, VS ; proc(f2, L, wait) PS) .
  eq [tempEQ21] : S |= filterLHSF2 = false [owise] .
  
  ceq [tempEQ22] : VS ; proc(I,  L, wait) PS |= filterLHSStar = true
    if I =/= f1 and I =/= f2
       and L < @NL and not conflict(I, L, VS ; proc(I, L, wait) PS) .
  eq [tempEQ23] : S |= filterLHSStar = false [owise] .
  
  
  ops critLHSF1 critLHSF2 critLHSStar : -> Prop [ctor] .
  ceq [tempEQ24] : VS ; proc(f1, L, on) PS |= critLHSF1 = true  if s L = @NL .
  eq [tempEQ25] : S |= critLHSF1 = false [owise] .
  
  ceq [tempEQ26] : VS ; proc(f2, L, on) PS |= critLHSF2 = true  if s L = @NL .
  eq [tempEQ27] : S |= critLHSF2 = false [owise] .
  
  ceq [tempEQ28] : VS ; proc(I,  L, on) PS |= critLHSStar = true
    if I =/= f1 and I =/= f2 and s L == @NL .
  eq [tempEQ29] : S |= critLHSStar = false [owise] .
  
  
  ops exitLHSF1 exitLHSF2 exitLHSStar : -> Prop [ctor] .
  eq [tempEQ30] : VS ; proc(f1, L, crit) PS |= exitLHSF1 = true .
  eq [tempEQ31] : S |= exitLHSF1 = false [owise] .
  
  eq [tempEQ32] : VS ; proc(f2, L, crit) PS |= exitLHSF2 = true .
  eq [tempEQ33] : S |= exitLHSF2 = false [owise] .
  
  ceq [tempEQ34] : VS ; proc(I,  L, crit) PS |= exitLHSStar = true
    if I =/= f1 and I =/= f2 .
  eq [tempEQ35] : S |= exitLHSStar = false [owise] .
  
  --- Defining Observations ---
  ---eq obs(S) = < obsUpto(S, waitLHS ; filterLHS ; critLHS ; exitLHS ; twoCrits) > .
  eq [tempEQ36] : obs(S) = < obsUpto(S,
    waitLHSF1 ; waitLHSF2 ; waitLHSStar ;
    filterLHSF1 ; filterLHSF2 ; filterLHSStar ;
    critLHSF1 ; critLHSF2 ; critLHSStar ;
    exitLHSF1 ; exitLHSF2 ; exitLHSStar ;
    twoCrits ) > .

  eq [tempEQ37] : reward(< FV:FeatVec , (twoCrits : true) , FV':FeatVec >) = 1.0 .
  eq [tempEQ38] : reward(MS:MDPState) = 0.0 [owise] .
  var P : Prop . var B : Bool .
  eq [tempEQ39] : < FV:FeatVec , (P : B) , FV':FeatVec > |= P = B . --- TODO: this may be default
endm


mod FILTER-TEST is
  protecting MODEL .
  op goal : -> Prop .
  eq [tempEQ40] : goal = twoCrits .
  ops init2 init3 init4 init5 init6 init7 init : -> Conf .
  eq [tempEQ41] : init2 = vict(1,0) ; proc(1, 0, on) proc(2, 0, on) . --- safe(no sol). why?
  eq [tempEQ42] : init3 = vict(1,0) vict(2,0) ; proc(1, 0, on) proc(2, 0, on) proc(3, 0, on) . --- error
  eq [tempEQ43] : init4 = vict(1,0) vict(2,0) vict(3,0) ; proc(1, 0, on) proc(2, 0, on) proc(3, 0, on) proc(4, 0, on) . --- error
  eq [tempEQ44] : init5 = vict(1,0) vict(2,0) vict(3,0) vict(4,0) ; proc(1, 0, on) proc(2, 0, on) proc(3, 0, on) proc(4, 0, on) proc(5, 0, on) . --- error
  eq [tempEQ45] : init6 = vict(1,0) vict(2,0) vict(3,0) vict(4,0) vict(5,0) ; proc(1, 0, on) proc(2, 0, on) proc(3, 0, on) proc(4, 0, on) proc(5, 0, on) proc(6, 0, on) . --- error
  eq [tempEQ46] : init7 = vict(1,0) vict(2,0) vict(3,0) vict(4,0) vict(5,0) vict(6,0) ; proc(1, 0, on) proc(2, 0, on) proc(3, 0, on) proc(4, 0, on) proc(5, 0, on) proc(6, 0, on) proc(7, 0, on) . --- error

  --- init3
  eq [tempEQ47] : init = init3 .
  eq [tempEQ48] : @NL = 2 .

  --- init4
  --- eq init = init4 .
  --- eq @NL = 3 .

  --- init5
  --- eq init = init5 .
  --- eq @NL = 4 .

  --- init6
  --- eq init = init6 .
  --- eq @NL = 5 .

  --- init7
  --- eq init = init7 .
  --- eq @NL = 6 .

endm


---search [1] init =>* VS:VictSet ; proc(I:Nat, L:Nat, crit) proc(J:Nat, L:Nat, crit) PS:ProcSet such that I:Nat =/= J:Nat .
